Working Notes
  
  ================================= TASK LIST
  
  - Add native file uploading
  - Add a native function for testing how long it's been since a user's last activity
    for example, in chat applications
  - Modify the login form to use keyup checks on the registration form. This will be
    sexier. Then when all the information is filled out the submit button becomes usable
    and when they submit, the server will double check (in case they modify something in
    dev tools).
  
  ================================= LEFT TO IMPLEMENT
  
  - Figure out the API -- obviously an API user should register for a key and include that in their request, so we
    will have to use a db check before sending them a response with information (another argument for a simple email
    based hash confirmation that we can use for everything and just slap different header messages on?)
  - Should have a way for people to decide whether they want to build with usernames emails and passwords or just 
    emails and passwords
  - (v2) Google Maps functionality...should be as simple as <div class="gmap"> and assigning a JSON array of coords
  - File uploads...multiple file uploading with progress bars, as well as image preview for profiles
  - Should have the user's avatar saved in the users table (need to add that column and put it in the installer)
  - Class "userpost" that automatically minifies links using an API? Or even YOURLS
  - Maybe generalize sending a confirmation link with hash into something simple like hashConfirm
    - In mino lang could attach everything to a name, and then go Name1 > hashConfirm > Name2 which would mean they
      would have to get a confirmation email to access Name2
  - Add jQuery password strength meter, username availability check, and a view password check box like working
    memory had.
  - Mino should have native and transparent editing-in-place abilities
  - (v2) Need an oauth implementation where they can just drop in their app ID thing and it works with twitter, fb 
    etc.
  
  ================================= LIST OF MINO FEATURES FOR WEBSITE
  
  "A high-level framework for realtime single-page websites on the LAMP stack" 
  
  "Built with web startups in mind, specifically the Startup Weekend crowd,
  who need to rapidly construct websites for their app or service on a stack
  they are already very familiar with. I thought the LAMP Edition would hit
  by far the most people. Pretty much every web developer has worked with it.
  And it runs easily on the cheap hosts that people use when their company is
  first starting out. Priorities were low barrier to entry, a wide potential
  user base, and easy access to progressive features that we're seeing from
  new startups with killer developers. That's why I abstracted these more
  advanced features to a very high level. People don't need to play with the
  timing of their fade-in or drop-down animations. They need to focus on their
  design, functionality, and getting to that first revision that they can sell. 
  With Mino, they can do it in record time."
  
  - JQuery 1.7 (latest) and uses features from this like .on
  - LAMP Edition works with Tasksel LAMP install, PEAR Mail, YUI Compressor
  - File hash-based caching, automatically compiles coffee, sass, less, and stylus too
  - Easy setup instructions for getting a fresh server going with Mino
  - Project assumes you want to use Google SMTP Mail Server (with its benefits) and is ready to go
  - Single file with all your response messages
  - Single file with all your email notifications
  - Simple set of pre-written emails that implement your site title, domain, and support email
  - HTML5 Shiv for IE before version 9
  - 100% Reliable HTML5 PushState with Hash fallbacks thanks to custom History.js implementation
  - Real-time MVC framework that supports loading dynamic views and subviews without page loads
    - Custom Mino HTML classes turn regular links into content-loaders with HTML5 and jQuery AJAX
    - Yes, you can pass URL variables to views and have them load content from models in real-time
    
  ================================= ABOUT MINO FRAMEWORK
    
  - Focuses more on the future than the past, and makes some tradeoffs that might not be suitable for some projects
    - Requires JS to function, but notifies users if they don't have JS on
  - Built for the web startup community
  - Built to make the LAMP stack feel more like emerging technology like Node.js/Express with LAMP stability base
    - A great transitional framework if you want to make LAMP projects with a modern feel and feature set
  
  ================================= IDEAS

  

  Could have middleware that is associated with each incoming model request. Just have 
  a folder for middleware (each would be its own file), and then have the model router
  grab them with a glob, analyze what model the content is going to, test it against
  a user-edited array connecting models to middleware, and then either process the
  incoming content and send it on to the model, or return a response before it even
  hits the model if it's for security.

  I think we're going to have to pass the full URL to the router and have it send back
  both a file location to load and an array of variables.

  Should make the .onLoad etc. classes just data-onLoad="" and then parse from there.
  Can grab them with jQuery $('[data-onload]')
  http://api.jquery.com/has-attribute-selector/
  
  Need to combine loadview and loadsubview like this:
      
      <a href="" data-loadview="dashboard, #walrus">

  The url variables can be standardized to ~a=b&b=c&c=d
  Just make an array out of all the variables so you can call them by name
  Pass that array to js
  
  You could have it to where when people land on a page it prompts them to log in
  and it holds the url variables and passes those in with the login?
  
  Router could be where we check sessions? Not index.php
  
  Still need to add ajax file uploading with progress bar
  
  Mino uses file structure and filesystem functions to decipher
  a website's structure, rather than storing that information in a database.
  
    To Do:
    
      - Make headers and footers in their own file structure in the client folder
      - Connect headers and footers to pages in router
      
      
  
